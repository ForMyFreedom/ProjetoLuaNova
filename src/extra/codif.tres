[gd_resource type="Resource" script_class="DialogicGlossary" load_steps=2 format=3 uid="uid://c8dd6lt01x616"]

[ext_resource type="Script" path="res://addons/dialogic/Modules/Glossary/glossary_resource.gd" id="1_iaaua"]

[resource]
script = ExtResource("1_iaaua")
entries = {
"Codif": {
"case_sensitive": true,
"text": "Codificação da Realidade (Magia)",
"title": "Codif"
},
"Condicional": {
"text": "Desvio do fluxo de processamento se algo é verdadeiro ou falso",
"title": "Condicional"
},
"Documento 1": {
"text": "if (x > y)
    printf(\"01100101\");
else
    printf(\"01100001\");",
"title": "Documento 1"
},
"Documento 2": {
"text": "if (a and b == true)
    printf(\"01110011\");
elseif (!(c or d) == true)
    printf(\"01110100\");
else
    printf(\"01100101\");",
"title": "Documento 2"
},
"Documento 3": {
"text": "if ((a >= b and b >= c) == true)
   printf(\"00\");
elseif ((c >= b and b >= a) == true)
   printf(\"01\");
else
   printf(\"10\");",
"title": "Documento 3"
},
"Função de Alta Ordem": {
"text": "Funções que geram funções e/ou recebem funções",
"title": "Função de Alta Ordem"
},
"Modelagem": {
"text": "Representar um problema computacionalmente",
"title": "Modelagem"
},
"Modelo de Substituição": {
"text": "Processo de avaliação em que expressões são trocadas por outras (normalmente mais simples)",
"title": "Modelo de Substituição"
},
"Parte 1 do Documento": {
"text": "struct nova_func
   char target_type[23];
   int target_neuron;
   int nova_type;
   int nova_neuron;
struct nova func = \"Land\", 19, 4, 5;",
"title": "Parte 1 do Documento"
},
"Parte 2 do Documento": {
"text": "struct nova f = \"Land\", 19, 4, 5;",
"title": "Parte 2 do Documento"
},
"Parte 3 do Documento": {
"text": "int experiment[24];
for (x = 0 ; x < 23; x++)
   experiment[x] = (x/10) * (f.target_neuron + f.nova_neuron);",
"title": "Parte 3 do Documento"
},
"Parte 4 do Documento": {
"text": "if (f.nova_type < experiment[4])
   for (x = 0; x < 23; x++)
      experiment[23-x] = experiment[22-x];
   experiment[0] = 13.8169 * f.nova_neuron;
else
   printf(\"Incompatible Beast\");",
"title": "Parte 4 do Documento"
},
"Rascunho 1": {
"text": "(define (quadrado x)
    (* x x))

(define (cubo x)
    (* x x x))

(define (divide-cubo-quadrado a b)
    (/ (cubo a) (quadrado b)))",
"title": "Rascunho"
},
"Recursão": {
"text": "Uma função que invoca a si mesma",
"title": "Recursão"
},
"Struct": {
"text": "Variável especial que contém diversas outras variáveis em sua composição",
"title": "Struct"
},
"Template-Salvação": {
"text": "(define (salvacao corpo_fonte vida_destino)
     (define caps_extraido
          (corpo-capacidades corpo_fonte)
     )
     ###
)"
},
"Template-Vida-2": {
"text": "(define (vida corpo)
   (lambda (dificuldade index)
      #processamento
   )
)"
},
"Vida Template": {
"text": "(define (vida corpo)
   (lambda (#entrada)
      #processamento
   )
)"
},
"XNOR": {
"text": "Porta Lógica 'Ou Exclusivo'
Verdadeiro só se A=B",
"title": "A⊙B"
},
"and": {
"text": "Somente verdadeiro quando A e B for verdadeiro",
"title": "A and B"
},
"cond": {
"text": "(cond [caso1 resposta1]  [caso 2 resposta2] [else respostaN])",
"title": "Condicional Geral"
},
"if": {
"text": "(if (caso_binario) res_verdade res_falso)",
"title": "Condicional Binário"
},
"lambda": {
"text": "Uma declaração de uma função sem nome",
"title": "Função Anônima"
},
"list-ref": {
"text": "Pega o elemento na posição '_index' de '_lista'",
"title": "(list-ref _lista _index)"
},
"not": {
"text": "Inverte o valor lógico de A",
"title": "not A"
},
"or": {
"text": "Somente verdadeiro quando A ou B for verdadeiro",
"title": "A or B"
},
"random": {
"text": "(random n) sorteia um valor de 0 a n",
"title": "Aleatório"
}
}
enabled = true
