[gd_resource type="Resource" script_class="DialogicGlossary" load_steps=2 format=3 uid="uid://c8dd6lt01x616"]

[ext_resource type="Script" path="res://addons/dialogic/Modules/Glossary/glossary_resource.gd" id="1_iaaua"]

[resource]
script = ExtResource("1_iaaua")
entries = {
"Codif": {
"case_sensitive": true,
"text": "Codificação da Realidade (Magia).",
"title": "Codif"
},
"Condicional": {
"text": "Desvio do fluxo de processamento se algo é verdadeiro ou falso.",
"title": "Condicional"
},
"Documento 1": {
"text": "if (x > y)
    printf(\"01100101\");
else
    printf(\"01100001\");",
"title": "Documento 1"
},
"Documento 2": {
"text": "if (a and b == true)
    printf(\"01110011\");
elseif (!(c or d) == true)
    printf(\"01110100\");
else
    printf(\"01100101\");",
"title": "Documento 2"
},
"Documento 3": {
"text": "if ((a >= b and b >= c) == true)
   printf(\"00\");
elseif ((c >= b and b >= a) == true)
   printf(\"01\");
else
   printf(\"10\");",
"title": "Documento 3"
},
"Função de Alta Ordem": {
"text": "Funções que geram funções e/ou recebem funções.",
"title": "Função de Alta Ordem"
},
"List": {
"alternatives": [],
"text": "Uma coleção de dados.",
"title": "(list dado1 dado2 ...)"
},
"Modelagem": {
"text": "Representar um problema computacionalmente.",
"title": "Modelagem"
},
"Modelo de Substituição": {
"text": "Processo em que expressões são trocadas por outras (normalmente mais simples).",
"title": "Modelo de Substituição"
},
"Parte 1 do Documento": {
"text": "struct nova
   char kind[23];
   int target;
   int origin;
   int neuron;",
"title": "Parte 1 do Documento"
},
"Parte 2 do Documento": {
"text": "struct nova f = \\{\"Land\", 19, 4, 5};",
"title": "Parte 2 do Documento"
},
"Parte 3 do Documento": {
"text": "int experiment[3] = \\{
	f.origin+f.target,
	f.neuron,
	f.origin
}",
"title": "Parte 3 do Documento"
},
"Rascunho 1": {
"text": "(define (quadrado x)
    (* x x)
)
(define (cubo x)
    (* x x x)
)
(define (divide-cubo-quadrado a b)
    (/ (cubo a) (quadrado b))
)",
"title": "Rascunho"
},
"Recursão": {
"text": "Uma função que invoca a si mesma.",
"title": "Recursão"
},
"Struct": {
"alternatives": ["struct", "structs", "Structs"],
"text": "Dado especial que contém diversos campos em sua composição.",
"title": "(struct _nome (...campos))"
},
"Template-Salvação": {
"text": "(define (salvacao corpo_fonte vida_destino)
     (define caps_extraido
          (corpo-capacidades corpo_fonte)
     )
     ###
)"
},
"Template-Vida-2": {
"text": "(define (vida corpo)
   (lambda (dificuldade index)
      #processamento
   )
)"
},
"Vida Template": {
"text": "(define (vida corpo)
   (lambda (#entrada)
      #processamento
   )
)"
},
"XNOR": {
"text": "Porta Lógica 'Ou Exclusivo'
Verdadeiro só se A=B",
"title": "XNOR"
},
"and": {
"text": "Somente verdadeiro quando A e B for verdadeiro.",
"title": "A and B"
},
"bool": {
"alternatives": ["Bool", "booleano", "Booleano"],
"text": "Valor que representa 'Falso' ou 'Verdadeiro'.",
"title": "Bool"
},
"cond": {
"text": "(cond [caso1 resposta1]  [caso 2 resposta2] [else respostaN])",
"title": "Condicional Geral"
},
"cons": {
"alternatives": ["Cons"],
"text": "Com um _dado_ e uma lista/vazio, é gerado um par (_dado, ...lista ou vazio)",
"title": "(cons _dado_ [lista/vazio])"
},
"fatorial": {
"text": "O produto de um natural com todos os naturais abaixo dele.",
"title": "Fatorial"
},
"if": {
"text": "(if (caso_binario) res_verdade res_falso)",
"title": "Condicional Binário"
},
"lambda": {
"alternatives": ["Lambda"],
"text": "Uma declaração de uma função sem nome.",
"title": "(lambda (arg1 arg2...) (código))"
},
"list-ref": {
"text": "Pega o elemento na posição '_index' de '_lista'",
"title": "(list-ref _lista _index)"
},
"not": {
"text": "Inverte o valor lógico de A.",
"title": "not A"
},
"or": {
"text": "Somente verdadeiro quando A ou B for verdadeiro.",
"title": "A or B"
},
"random": {
"text": "(random n) sorteia um valor de 0 a n.",
"title": "Aleatório"
},
"string": {
"alternatives": ["String"],
"text": "Dado do tipo texto.",
"title": "Texto"
}
}
enabled = true
